import{_ as e,o,c as a,V as t}from"./chunks/framework.a215caf7.js";const u=JSON.parse('{"title":"box-shadow 属性无效","description":"","frontmatter":{},"headers":[],"relativePath":"bugs/bug001.md","filePath":"bugs/bug001.md","lastUpdated":1689440421000}'),d={name:"bugs/bug001.md"},c=t('<h1 id="box-shadow-属性无效" tabindex="-1">box-shadow 属性无效 <a class="header-anchor" href="#box-shadow-属性无效" aria-label="Permalink to &quot;box-shadow 属性无效&quot;">​</a></h1><h2 id="_1-原因分析" tabindex="-1">1.原因分析 <a class="header-anchor" href="#_1-原因分析" aria-label="Permalink to &quot;1.原因分析&quot;">​</a></h2><ul><li>在单独盒子中的元素, <code>box-shadow</code> 的阴影会投影到父级上, <strong>但是如果阴影盒子是紧贴的</strong>, 那么阴影就不可见了</li></ul><h2 id="_2-解决方案" tabindex="-1">2.解决方案: <a class="header-anchor" href="#_2-解决方案" aria-label="Permalink to &quot;2.解决方案:&quot;">​</a></h2><ol><li><p>在需要的 <code>box-shadow</code> 的元素设置 <code>position: relative</code>:</p><p>使用 <code>position: relative:</code> 在正常文档流中, 紧贴着意味着元素涂在父级上的阴影被旁边元素覆盖再次涂写, 所以设置 <code>position: relative</code> 就让元素脱离文档流, 浏览器单独处理, 就出现了 z 轴上的堆叠, 也就不存在被紧贴着, 阴影就直接投影在正常文档流之上.</p></li><li><p>在父级上设置 <code>flex</code>, 然后在需要阴影的元素设置 <code>z-index</code> 大于等于0</p><p><code>flex</code> 会让直接子元素变为一种 <code>flex-item</code> 元素, 这个时候就不能称为文档流了, <code>flex-item</code> 就有了 z 轴的概念, 所以设置 <code>z-index</code> 就能调整阴影出现的堆叠层次.</p></li></ol>',5),i=[c];function s(l,r,n,_,h,p){return o(),a("div",null,i)}const x=e(d,[["render",s]]);export{u as __pageData,x as default};
